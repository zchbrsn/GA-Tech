# Static Analysis
```bash
# Checksec
checksec --file=<File>

# Check functions
objdump -D <File> | less

# Read symbols
ldd <File>
readelf -s <libc> | grep <Function>



# Convert something from hex
echo -en "<Hex>" | xxd -r -p

# Create shellcode
shellcraft -l
shellcraft i386.linux.sh -f d


# Find /bin/sh in binary
# Get base address of libc
ldd <Binary>

# Get location of system()
readelf -s <Libc> | grep system

# Get location of exit()
readelf -s <Libc> | grep exit

# Get location of /bin/sh
strings -a -t x <Libc> | grep "/bin/sh"

libc_base = <Address>
system = libc_base + <Address>
binsh = libc_base + <Address

```

# GDB
```gdb
Resources:
https://www.exploit-db.com/papers/13205

# Start the binary, core, or process
gdb <Binary>
gdb -c <Core>
gdb -silent `pidof <Binary>`

# Set arguments
set args `perl -e 'print "A" x 5000'`

# Set environment variables
set env PATH=`perl -e 'print "A" x 5000'`

# Change from att to intel
set disassembly-flavor intel

# Check functions
info functions

# Set breakpoints
b main
break strcpy

# Check addresses of libc functions
p system
p puts
p scanf

# Examine
x $ebp		# Examine a register (ebp, eax, etc)
x $eip		# Examine the instruction pointer

# Set values
set *0x<Offset> = <Value>

# Get memory maps
vm

# List breakpoints
info b

# Run the binary
run

# Show register addresses
i r

# Show function disassembly
disas
disas main

# Show stored values on the stack
print $esp

# Check memory address of a location
x		# Examine
g		# 8 bytes
x		# Hexadecimal
$rsp		# Stack pointer
x/gx $rsp

# Strings
x/s $rip
p/s *main+<Num>

# Check stack frame
info frame

# Check memory addresses of variables for calculating offset distances
p &<Variable 1>
p &<Variable 2>
offset = <Variable 1> - <Variable 2>

# pdb cyclic
cyclic <Num>

# GEF Pattern create
pattern create <Num>

r

# Find the offset of the rsp
pattern offset $rsp

pattern create <Offset>

# Find an offset in libc
info proc map				# Program must be running
strings -a -t x /lib/libc-2.11.2.so | grep "/bin/sh"
x/s <Libc Address> + <Strings Address>

# Find /bin/sh in system
disas main
break *<Ret Main>
print &system
find &system, +9999999, "/bin/sh"

# Find size of buffer needed to overflow in gdb 
1. Break after function
2. Run
3. Enter input
4. info frame

Stack level 0, frame at 0x7fffffffdea0:
 rip = 0x4006a3 in main; saved rip = 0x7ffff7a05b97
 Arglist at 0x7fffffffde90, args:
 Locals at 0x7fffffffde90, Previous frame's sp is 0x7fffffffdea0
 Saved registers:
  rbp at 0x7fffffffde90, rip at 0x7fffffffde98

5. search-pattern <Input>

[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw-
  0x7fffffffde50 - 0x7fffffffde58  â†’   "15935728"

6. hex(0x7fffffffde98 - 0x7fffffffde50)
'0x48'

# Search for strings in binary
search "/bin/cat"
```

# ROP
```bash
# Register Order
RDI
RSI
RDX
RCX
R8
R9

# 64 bit get a ROP
ROPgadget --binary <Binary> | grep rdi
	pop rdi ; ret

# Ropper
ropper --file badchars32 --search "<ROP>" -b "<Chars>"

# Put /bin/sh in rdi
payload += p64(POP_RDI)
payload += p64(binsh)
payload += p64(system)
payload += p64(0x0)
```
